"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageImpl = void 0;
const numeral_1 = __importDefault(require("numeral"));
const date_fns_1 = require("date-fns");
class LanguageImpl {
    constructor(languageCommon) {
        this.iso2 = null;
        this.langForNumeral = null; // when using numeral
        this.langForDateFns = undefined; // when using date-fns
        this.defaultDateFormat = 'yyyy-MM-dd';
        this.n2wordsLang = null; // when using n2words
        this.n2wordsLib = null; // when using n2words
        this.floatingPointWord = null; // when using n2words
        this.table0to9 = null;
        this.hasGender = null;
        this.hasNeutral = null;
        this.defaultAdjPos = null; // 'BEFORE' or 'AFTER'
        this.hasCase = null;
        this.defaultCase = null;
        this.userGenderOwnedForGender = null; // German only?
        this.eatSpaceWhenAdjEndsWithApostrophe = null; // Italian only
        this.supportsInvertSubjectVerb = null; // German atm
        this.defaultTense = null;
        this.canPopVerbPart = null; // German only
        this.canPopVerbPrefix = null; // German only
        this.defaultLastSeparatorForAdjectives = null;
        this.universalMapping = null;
        this.spacesWhenSeparatingElements = null; // when listing elements, put spaces or not; false e.g. for Chinese
        this.valueManager = null;
        this.verbsManager = null;
        this.refsManager = null;
        this.genderNumberManager = null;
        this.spy = null;
        this.helper = null;
        this.languageCommon = languageCommon;
    }
    setValueManager(valueManager) {
        this.valueManager = valueManager;
    }
    setVerbsManager(verbsManager) {
        this.verbsManager = verbsManager;
    }
    setRefsManager(refsManager) {
        this.refsManager = refsManager;
    }
    setGenderNumberManager(genderNumberManager) {
        this.genderNumberManager = genderNumberManager;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getSpy() {
        return this.spy;
    }
    setHelper(helper) {
        this.helper = helper;
    }
    // shortcut
    getDictManager() {
        return this.languageCommon.dictManager;
    }
    getLanguageCommon() {
        return this.languageCommon;
    }
    getDefaultLastSeparatorForAdjectives() {
        if (!this.defaultLastSeparatorForAdjectives) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `no default last separator for ${this.iso2} language`;
            throw err;
        }
        else {
            return this.defaultLastSeparatorForAdjectives;
        }
    }
    getDet(_det, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `determiners not available in ${this.iso2}`;
        throw err;
    }
    /* istanbul ignore next */
    getAgreeAdj(_adjective, _gender, _number, _subject, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `adjectives not available in ${this.iso2}`;
        throw err;
    }
    getWordGender(_word) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `there is no gender dict for ${this.iso2}, set gender directly`;
        throw err;
    }
    getOrdinal(_val, _gender) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `ORDINAL_TEXTUAL not available in ${this.iso2}`;
        throw err;
    }
    // this is explicitely tied to numeral lib
    getFormatNumberWithNumeral(val, format) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return (0, numeral_1.default)(val).format(format);
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `FORMAT not available in ${this.iso2}`;
            throw err;
        }
    }
    // this is just a default implementation using numeral, it can be overriden
    getOrdinalNumber(val, _gender) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return (0, numeral_1.default)(val).format('o');
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `ORDINAL_NUMBER not available in ${this.iso2}`;
            throw err;
        }
    }
    // default implementation using n2words
    getTextualNumber(val, _gender) {
        if (this.n2wordsLib && this.n2wordsLang) {
            let res = '';
            if (val % 1 === 0) {
                // is int
                res = this.n2wordsLib(val, { lang: this.n2wordsLang });
            }
            else {
                // is float
                const splitVal = (val + '').split('.');
                res =
                    this.n2wordsLib(parseInt(splitVal[0]), { lang: this.n2wordsLang }) +
                        ' ' +
                        this.floatingPointWord +
                        ' ' +
                        this.getTextualNumberFloatPart(splitVal[1]);
            }
            return res;
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `TEXTUAL not available in ${this.iso2}`;
            throw err;
        }
    }
    // very basic default implementation
    getTextualNumberFloatPart(floatPartString) {
        /* istanbul ignore else */
        if (this.table0to9) {
            const resArr = [];
            for (let i = 0; i < floatPartString.length; i++) {
                resArr.push(this.table0to9[Number(floatPartString.charAt(i))]);
            }
            return resArr.join(' ');
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `TEXTUAL with floating point parts not available in ${this.iso2}`;
            throw err;
        }
    }
    // override if necessary
    getStdFormatedNumber(val) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return (0, numeral_1.default)(val).format('0,0.[000000000000]');
        }
        else {
            // default, not so good
            return val.toString();
        }
    }
    // default implementation using date-fns
    getFormattedDate(date, dateFormat) {
        return (0, date_fns_1.format)(date, dateFormat || this.defaultDateFormat, { locale: this.langForDateFns });
    }
    // possessiveAdj currently only in Italian
    getFormattedNominalGroup(possessiveAdj, adjBefore, substantive, adjAfter) {
        if (!possessiveAdj) {
            // not tested in Chinese
            /* istanbul ignore next */
            const sep = this.spacesWhenSeparatingElements ? '¤' : '';
            return (adjBefore ? adjBefore + sep : '') + substantive + (adjAfter ? sep + adjAfter : '');
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `possessive adjective not available in ${this.iso2}`;
            throw err;
        }
    }
    /* istanbul ignore next */
    parseSimplifiedString(_val) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `<...> syntax not implemented in ${this.iso2}`;
        throw err;
    }
    // when reference has to be triggered
    thirdPossessionTriggerRef(_owner, _owned, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `thirdPossessionTriggerRef not available in ${this.iso2}`;
        throw err;
    }
    // reference has already been triggered
    thirdPossessionRefTriggered(_owner, _owned, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `thirdPossessionRefTriggered not available in ${this.iso2}`;
        throw err;
    }
    recipientPossession(_owned) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `recipientPossession not implemented in ${this.iso2}`;
        throw err;
    }
    // helper to map with language specific conjugation libs
    mapPersonToNumber0to5(person) {
        const personMapping = {
            '1S': 0,
            '2S': 1,
            '3S': 2,
            '1P': 3,
            '2P': 4,
            '3P': 5,
        };
        return personMapping[person];
    }
    // helper to map with language specific conjugation libs
    mapPersonToNumber1to3(person) {
        return {
            '1S': 1,
            '1P': 1,
            '2S': 2,
            '2P': 2,
            '3S': 3,
            '3P': 3,
        }[person];
    }
    // helper to map with language specific conjugation libs
    mapPersonToSP(person) {
        return {
            '1S': 'S',
            '1P': 'P',
            '2S': 'S',
            '2P': 'P',
            '3S': 'S',
            '3P': 'P',
        }[person];
    }
    getConjugation(_subject, _verb, _tense, _person, _conjParams, _embeddedVerbs, _verbParts, _verbPrefixes) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `verbs not available in ${this.iso2}`;
        throw err;
    }
    isVerbWithPrefix(_verb, _embeddedVerbs) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `isVerbWithPrefix is not available for ${this.iso2}`;
        throw err;
    }
    isPlural(_val) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `isPlural not implemented in ${this.iso2}`;
        throw err;
    }
    sentence(_sentenceParams) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `sentence mixin not implemented in ${this.iso2}`;
        throw err;
    }
    /* istanbul ignore next */
    getPersonalPronounSubject(_person) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `personal pronoun subject not implemented in ${this.iso2}`;
        throw err;
    }
    addSeparatingSpace() {
        this.getSpy().appendPugHtml(this.helper.getSeparatingSpace());
    }
    solveTense(originalTense) {
        if (this.universalMapping && this.universalMapping[originalTense]) {
            return this.universalMapping[originalTense];
        }
        else {
            return originalTense;
        }
    }
}
exports.LanguageImpl = LanguageImpl;
//# sourceMappingURL=LanguageImpl.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerbsManager = void 0;
class VerbsManager {
    constructor(languageImpl, genderNumberManager, synManager, saveRollbackManager, helper) {
        this.embeddedVerbs = undefined;
        this.spy = undefined;
        this.languageImpl = languageImpl;
        this.genderNumberManager = genderNumberManager;
        this.synManager = synManager;
        this.saveRollbackManager = saveRollbackManager;
        this.helper = helper;
        this.verbParts = [];
        this.verbPrefixes = [];
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getSpy() {
        return this.spy;
    }
    getVerbPartsList() {
        return this.verbParts;
    }
    setVerbPartsList(verbParts) {
        this.verbParts = verbParts;
    }
    getVerbPrefixesList() {
        return this.verbPrefixes;
    }
    setVerbPrefixes(verbPrefixes) {
        this.verbPrefixes = verbPrefixes;
    }
    setEmbeddedVerbs(embeddedVerbs) {
        this.embeddedVerbs = embeddedVerbs;
    }
    encapsulateConjParams(conjParams) {
        if (typeof conjParams === 'object' && !Array.isArray(conjParams)) {
            // already in .verb prop
            return conjParams;
        }
        else {
            // direct arg: string or array
            return {
                verb: conjParams,
            };
        }
    }
    getAgreeVerb(subject, person, conjParamsOriginal, additionalParams) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            return 'SOME_VERB';
        }
        else {
            const conjParams = this.encapsulateConjParams(conjParamsOriginal);
            const verbName = this.synManager.synFctHelper(conjParams.verb);
            if (!verbName) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `verb needed`;
                throw err;
            }
            const tense = (conjParams.tense || this.languageImpl.defaultTense);
            let paramPerson = person;
            if (!paramPerson) {
                if (this.genderNumberManager.getRefNumber(subject, additionalParams) === 'P') {
                    paramPerson = '3P';
                }
                else {
                    paramPerson = '3S';
                }
            }
            return this.languageImpl.getConjugation(subject, verbName, tense, paramPerson, conjParams, this.embeddedVerbs, this.verbParts, this.verbPrefixes);
        }
    }
    doPopHelper(toPop) {
        const popped = toPop.pop();
        if (!popped) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `nothing to pop`;
            throw err;
        }
        this.getSpy().appendPugHtml(this.helper.getSeparatingSpace() + popped + this.helper.getSeparatingSpace());
    }
    popVerbPartInBuffer() {
        if (!this.languageImpl.canPopVerbPart) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPart is not available for ${this.languageImpl.iso2}`;
            throw err;
        }
        this.doPopHelper(this.verbParts);
    }
    popVerbPrefixInBuffer() {
        if (!this.languageImpl.canPopVerbPrefix) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPrefix is not available for ${this.languageImpl.iso2}`;
            throw err;
        }
        this.doPopHelper(this.verbPrefixes);
    }
    isVerbWithPrefix(verb) {
        return this.languageImpl.isVerbWithPrefix(verb, this.embeddedVerbs);
    }
}
exports.VerbsManager = VerbsManager;
//# sourceMappingURL=VerbsManager.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageItalian = void 0;
const LanguageImpl_1 = require("./LanguageImpl");
const italian_determiners_1 = require("italian-determiners");
const italian_adjectives_1 = require("italian-adjectives");
const adjectives_json_1 = __importDefault(require("italian-adjectives-dict/dist/adjectives.json"));
const italian_words_1 = require("italian-words");
const words_json_1 = __importDefault(require("italian-words-dict/dist/words.json"));
const italian_ordinals_cardinals_1 = require("italian-ordinals-cardinals");
require("numeral/locales/it");
const locale_1 = require("date-fns/locale");
const italian_grammar_js_1 = require("../dist/italian-grammar.js");
const morph_it_helper_1 = require("morph-it-helper");
const italian_verbs_1 = require("italian-verbs");
const verbs_json_1 = __importDefault(require("italian-verbs-dict/dist/verbs.json"));
const n2words_IT_js_1 = __importDefault(require("../../rosaenlg-n2words/dist/n2words_IT.js"));
class LanguageItalian extends LanguageImpl_1.LanguageImpl {
    constructor(languageCommon) {
        super(languageCommon);
        this.iso2 = 'it';
        this.langForNumeral = 'it';
        this.langForDateFns = locale_1.it;
        this.n2wordsLang = 'it';
        this.n2wordsLib = n2words_IT_js_1.default;
        this.floatingPointWord = 'punto';
        this.table0to9 = ['zero', 'uno', 'due', 'tre', 'quattro', 'cinque', 'sei', 'sette', 'otto', 'nove'];
        this.hasGender = true;
        this.hasNeutral = false;
        this.defaultAdjPos = 'AFTER'; // l'adjectif qualificatif se place généralement après le nom mais peut également le précéder
        this.eatSpaceWhenAdjEndsWithApostrophe = true;
        this.defaultTense = 'PRESENTE';
        this.defaultLastSeparatorForAdjectives = 'e';
        this.universalMapping = {
            UNIVERSAL_PRESENT: 'PRESENTE',
            UNIVERSAL_PAST: 'IMPERFETTO',
            UNIVERSAL_FUTURE: 'FUTURO_SEMPLICE',
            UNIVERSAL_PERFECT: 'PASSATO_PROSSIMO',
            UNIVERSAL_PLUPERFECT: 'TRAPASSATO_PROSSIMO',
        };
        this.spacesWhenSeparatingElements = true;
        try {
            this.dictHelper = new morph_it_helper_1.MorphItHelper();
        }
        catch (err) {
            // this means that we are in a browser
        }
    }
    getDet(det, params) {
        // istanbul ignore next
        return (0, italian_determiners_1.getDet)(det, params.genderOwned, params.numberOwned || 'S', params.dist); // || S will be tested when possessives added
    }
    getAgreeAdj(adjective, gender, number, subject, params) {
        return (0, italian_adjectives_1.agreeItalianAdjective)(this.getDictManager().getAdjsData(), adjectives_json_1.default, adjective, gender, number, subject, params && params.adjPos === 'BEFORE');
    }
    getWordGender(word) {
        return (0, italian_words_1.getGenderItalianWord)(this.getDictManager().getWordData(), words_json_1.default, word); //NOSONAR
    }
    getOrdinal(val, gender) {
        return (0, italian_ordinals_cardinals_1.getOrdinal)(val, gender);
    }
    getFormattedNominalGroup(possessiveAdj, adjBefore, substantive, adjAfter) {
        if (adjBefore.endsWith("'")) {
            // bell'uomo
            return `${possessiveAdj} ${adjBefore}${substantive} ${adjAfter}`;
        }
        else {
            return `${possessiveAdj} ${adjBefore} ${substantive} ${adjAfter}`;
        }
    }
    getSubstantive(subst, number) {
        if (number === 'S') {
            return subst;
        }
        else {
            return (0, italian_words_1.getNumberItalianWord)(this.getDictManager().getWordData(), words_json_1.default, subst, number); //NOSONAR
        }
    }
    parseSimplifiedString(val) {
        return (0, italian_grammar_js_1.parse)(val, { dictHelper: this.dictHelper });
    }
    getConjugation(_subject, verb, originalTense, person, conjParams, embeddedVerbs) {
        const solvedTense = this.solveTense(originalTense);
        let aux = undefined;
        if (conjParams && conjParams.aux) {
            aux = conjParams.aux;
        }
        let agreeGender = undefined;
        let agreeNumber = undefined;
        if (conjParams && conjParams.agree) {
            agreeGender = this.genderNumberManager.getRefGender(conjParams.agree, null);
            agreeNumber = this.genderNumberManager.getRefNumber(conjParams.agree, null);
        }
        return (0, italian_verbs_1.getConjugation)(embeddedVerbs || verbs_json_1.default, // give the verbs that we embedded in the compiled template, if there are some
        verb, solvedTense, this.mapPersonToNumber1to3(person), this.mapPersonToSP(person), { aux: aux, agreeGender: agreeGender, agreeNumber: agreeNumber });
    }
    isPlural(val) {
        // https://groups.google.com/g/it.scienza.matematica/c/UogaRZ4tSb8
        if (val === 1 || val === -1) {
            return false;
        }
        else {
            return true;
        }
    }
}
exports.LanguageItalian = LanguageItalian;
//# sourceMappingURL=LanguageItalian.js.map
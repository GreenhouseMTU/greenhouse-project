/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
import { FrenchAux, Tense as FrenchTenses, Voice } from 'french-verbs';
import 'numeral/locales/fr';
import { LanguageCommon, VerbsInfo } from 'rosaenlg-commons';
import { AgreeAdjParams, DetParams, DetTypes, GrammarParsed, LanguageImpl, SomeTense } from './LanguageImpl';
import { Genders, GendersMF, Numbers } from './NlgLib';
import { PersonForSentence, SentenceParams } from './SentenceManager';
import { ValueParams } from './ValueManager';
import { ConjParams } from './VerbsManager';
export type FrenchTense = FrenchTenses;
export declare const frenchTenses: readonly ["PRESENT", "FUTUR", "IMPARFAIT", "PASSE_SIMPLE", "PASSE_COMPOSE", "PLUS_QUE_PARFAIT", "PASSE_ANTERIEUR", "FUTUR_ANTERIEUR", "CONDITIONNEL_PRESENT", "CONDITIONNEL_PASSE_1", "CONDITIONNEL_PASSE_2", "IMPERATIF_PRESENT", "IMPERATIF_PASSE", "SUBJONCTIF_PRESENT", "SUBJONCTIF_IMPARFAIT", "SUBJONCTIF_PASSE", "SUBJONCTIF_PLUS_QUE_PARFAIT", "INFINITIF", "INFINITIF_PASSE", "PARTICIPE_PRESENT", "PARTICIPE_PASSE", "PARTICIPE_PASSE_COMPOSE"];
interface SentenceParamsFr extends SentenceParams {
    negativeAdverb?: string;
    modifierAdverb?: string;
}
interface ConjParamsFr extends ConjParams {
    tense: string;
    agree: any;
    aux: FrenchAux;
    negativeAdverb: string | undefined;
    modifierAdverb: string | undefined;
    voice: Voice;
}
export declare class LanguageFrench extends LanguageImpl {
    iso2: string;
    langForNumeral: string;
    langForDateFns: Locale;
    n2wordsLang: string;
    n2wordsLib: any;
    floatingPointWord: string;
    table0to9: string[];
    hasGender: boolean;
    hasNeutral: boolean;
    defaultAdjPos: string;
    defaultTense: string;
    defaultLastSeparatorForAdjectives: string;
    universalMapping: {
        UNIVERSAL_PRESENT: string;
        UNIVERSAL_PAST: string;
        UNIVERSAL_FUTURE: string;
        UNIVERSAL_PERFECT: string;
        UNIVERSAL_PLUPERFECT: string;
    };
    spacesWhenSeparatingElements: boolean;
    constructor(languageCommon: LanguageCommon);
    getDet(detType: DetTypes, params: DetParams): string;
    getAgreeAdj(adjective: string, gender: Genders, number: Numbers, subject: any, params: AgreeAdjParams): string;
    getWordGender(word: string): GendersMF;
    getOrdinal(val: number, gender: Genders): string;
    getTextualNumber(val: number, gender: Genders | undefined): string;
    getOrdinalNumber(val: number, gender: Genders | undefined): string;
    getSubstantive(subst: string, number: Numbers): string;
    parseSimplifiedString(val: string): GrammarParsed;
    thirdPossessionTriggerRef(owner: any, owned: any, params: ValueParams): void;
    thirdPossessionRefTriggered(owner: any, owned: any, params: ValueParams): void;
    recipientPossession(owned: any): void;
    getConjugation(subject: any, verb: SomeTense, originalTense: string, person: PersonForSentence, conjParams: ConjParamsFr, embeddedVerbs: VerbsInfo): string;
    isPlural(val: number): boolean;
    getPersonalPronounSubject(person: PersonForSentence): string;
    getDirectObjPronoun(gender: Genders | undefined, number: Numbers | undefined, person?: PersonForSentence): string;
    getIndirectObjPronoun(gender: Genders | undefined, number: Numbers | undefined, person?: PersonForSentence): string;
    sentence(sentenceParams: SentenceParamsFr): void;
}
export {};

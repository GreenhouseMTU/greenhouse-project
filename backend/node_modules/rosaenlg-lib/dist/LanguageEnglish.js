"use strict";
/**
 * @license
 * Copyright 2019 Ludan StoecklÃ©
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageEnglish = void 0;
const locale_1 = require("date-fns/locale");
const english_determiners_1 = require("english-determiners");
const english_ordinals_1 = require("english-ordinals");
const english_plurals_1 = require("english-plurals");
const plurals_json_1 = __importDefault(require("english-plurals-list/dist/plurals.json"));
const gerunds_json_1 = __importDefault(require("english-verbs-gerunds/dist/gerunds.json"));
const english_verbs_helper_1 = require("english-verbs-helper");
const verbs_json_1 = __importDefault(require("english-verbs-irregular/dist/verbs.json"));
const n2words_EN_js_1 = __importDefault(require("../../rosaenlg-n2words/dist/n2words_EN.js"));
const english_grammar_js_1 = require("../dist/english-grammar.js");
const LanguageImpl_1 = require("./LanguageImpl");
class LanguageEnglish extends LanguageImpl_1.LanguageImpl {
    constructor(languageCommon) {
        super(languageCommon);
        this.iso2 = 'en';
        this.langForNumeral = 'en';
        this.langForDateFns = locale_1.enUS;
        this.n2wordsLang = 'en';
        this.n2wordsLib = n2words_EN_js_1.default;
        this.floatingPointWord = 'point';
        this.table0to9 = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
        this.hasGender = false;
        this.hasNeutral = true;
        this.defaultAdjPos = 'BEFORE';
        this.defaultTense = 'PRESENT';
        this.defaultLastSeparatorForAdjectives = 'and';
        this.universalMapping = {
            UNIVERSAL_PRESENT: 'SIMPLE_PRESENT',
            UNIVERSAL_PAST: 'SIMPLE_PAST',
            UNIVERSAL_FUTURE: 'SIMPLE_FUTURE',
            UNIVERSAL_PERFECT: 'PERFECT_PRESENT',
            UNIVERSAL_PLUPERFECT: 'PERFECT_PAST',
        };
        this.spacesWhenSeparatingElements = true;
        // create English combined resource
        this.mergedVerbsDataEn = (0, english_verbs_helper_1.mergeVerbsData)(verbs_json_1.default, gerunds_json_1.default);
    }
    getDet(det, params) {
        return (0, english_determiners_1.getDet)(det, params.genderOwner, params.numberOwner || 'S', params.numberOwned || 'S', params.dist, params.useTheWhenPlural);
    }
    getAgreeAdj(adjective /*, gender: Genders, number: Numbers, subject: any, params: AgreeAdjParams*/) {
        // no agreement for adjectives in English
        return adjective;
    }
    getOrdinal(val) {
        return (0, english_ordinals_1.getOrdinal)(val); // throws Exception if is not able to generate an ordinal
    }
    getSubstantive(subst, number) {
        if (number === 'S') {
            return subst;
        }
        else {
            return (0, english_plurals_1.getPlural)(this.getDictManager().getWordData(), plurals_json_1.default, subst);
        }
    }
    parseSimplifiedString(val) {
        return (0, english_grammar_js_1.parse)(val, {
        /* no dict */
        });
    }
    thirdPossessionTriggerRef(owner, owned, params) {
        let possForm;
        if (params && params.possForm) {
            if (params.possForm === 'OF' || params.possForm === 'S') {
                possForm = params.possForm;
            }
            else {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `possForm must be either OF or S`;
                throw err;
            }
        }
        else {
            possForm = 'OF';
        }
        switch (possForm) {
            case 'OF': {
                this.valueManager.value(owned, Object.assign({}, params, { det: 'DEFINITE' }));
                this.getSpy().appendPugHtml(` of `);
                this.valueManager.value(owner, Object.assign({}, params));
                break;
            }
            case 'S': {
                this.valueManager.value(owner, Object.assign({}, params));
                this.getSpy().appendPugHtml(`'s`);
                this.helper.insertSeparatingSpaceIfRequired();
                this.valueManager.value(owned, Object.assign({}, params));
                break;
            }
        }
    }
    thirdPossessionRefTriggered(owner, owned, params) {
        const det = this.getDet('POSSESSIVE', {
            genderOwned: undefined,
            genderOwner: this.genderNumberManager.getRefGender(owner, params),
            numberOwner: this.genderNumberManager.getRefNumber(owner, params),
            numberOwned: undefined,
            case: undefined,
            dist: undefined,
            after: undefined,
            useTheWhenPlural: undefined,
        });
        this.getSpy().appendPugHtml(` ${det} ${owned} `);
    }
    recipientPossession(owned) {
        this.getSpy().appendPugHtml('your');
        this.valueManager.value(owned, { _OWNER: true });
    }
    getConjugation(_subject, verb, tense, person, conjParams, embeddedVerbs) {
        return (0, english_verbs_helper_1.getConjugation)(embeddedVerbs || this.mergedVerbsDataEn, verb, this.solveTense(tense), this.mapPersonToNumber0to5(person), conjParams);
    }
    isPlural(val) {
        if (val === 1 || val === -1) {
            return false;
        }
        else {
            return true;
        }
    }
    getObjectPronoun(gender, number) {
        if (number === 'P') {
            return 'them';
        }
        else {
            switch (gender) {
                case 'M':
                    return 'him';
                case 'F':
                    return 'her';
                default:
                    // N
                    return 'it';
            }
        }
    }
    getPersonalPronounSubject(person) {
        /* istanbul ignore next */
        if (person === '3S') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `personal pronoun subject unknown: could be he / she / it`;
            throw err;
        }
        return {
            '1S': 'I',
            '2S': 'you',
            '1P': 'we',
            '2P': 'you',
            '3P': 'they',
        }[person];
    }
    sentence(sentenceParams) {
        if (sentenceParams.subjectGroup.person === '3S' && !sentenceParams.subjectGroup.subject) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `in sentence, when using 3S person, subject object is required`;
            throw err;
        }
        if (sentenceParams && sentenceParams.hasOwnProperty('modifierAdverb')) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `in sentence, modifierAdverb is not supported in English`;
            throw err;
        }
        const subjectGroup = sentenceParams.subjectGroup;
        const subject = subjectGroup.subject;
        const verbalGroup = sentenceParams.verbalGroup;
        const hasVerb = verbalGroup && verbalGroup.verb;
        const objGroups = sentenceParams.objGroups != null ? sentenceParams.objGroups : [];
        // subject
        if (subjectGroup.noSubject !== true) {
            if (subjectGroup.person === '1S' ||
                subjectGroup.person === '2S' ||
                subjectGroup.person === '1P' ||
                subjectGroup.person === '2P' ||
                (subjectGroup.person === '3P' && !subjectGroup.subject)) {
                // use pronoun
                this.valueManager.value(this.getPersonalPronounSubject(subjectGroup.person), undefined);
            }
            else {
                this.valueManager.value(subjectGroup.subject, undefined);
            }
            this.addSeparatingSpace();
        }
        // verb
        if (hasVerb) {
            const modifiedVerbalGroup = Object.assign({}, verbalGroup);
            if (sentenceParams.negative) {
                modifiedVerbalGroup.NEGATIVE = true;
                modifiedVerbalGroup.CONTRACT = sentenceParams.contractNegation;
                modifiedVerbalGroup.NO_DO = sentenceParams.negationNoDo;
            }
            this.valueManager.value(this.verbsManager.getAgreeVerb(subject, subjectGroup.person, modifiedVerbalGroup, null), undefined);
            this.addSeparatingSpace();
        }
        const reorderedObjGroups = [...objGroups];
        /*
          if an indirect object in normal form is followed by a direct object in pronoun form: we do invert
          e.g. 'he gave the neighbor apples' => 'he gave them to the neighbor' (or not 'he gave the neighbor them')
        */
        for (let i = 0; i < reorderedObjGroups.length; i++) {
            const objGroup = reorderedObjGroups[i];
            if (i >= 1 && objGroup.type === 'DIRECT' && this.refsManager.hasTriggeredRef(objGroup.obj)) {
                const precObjGroup = reorderedObjGroups[i - 1];
                if (precObjGroup.type === 'INDIRECT' && !this.refsManager.hasTriggeredRef(precObjGroup.obj)) {
                    reorderedObjGroups[i - 1] = objGroup;
                    reorderedObjGroups[i] = precObjGroup;
                }
            }
        }
        for (let i = 0; i < reorderedObjGroups.length; i++) {
            const objGroup = reorderedObjGroups[i];
            // add 'to' if indirect AND preceded by direct object (pronoun or complete form)
            if (objGroup.type === 'INDIRECT' && i >= 1 && reorderedObjGroups[i - 1].type === 'DIRECT') {
                this.valueManager.value('to', undefined);
                this.addSeparatingSpace();
            }
            if (this.refsManager.hasTriggeredRef(objGroup.obj)) {
                // pronoun
                const gender = this.genderNumberManager.getRefGender(objGroup.obj, null);
                const number = this.genderNumberManager.getRefNumber(objGroup.obj, null);
                const pronoun = this.getObjectPronoun(gender, number);
                this.valueManager.value(pronoun, undefined);
            }
            else {
                // complete form
                this.valueManager.value(objGroup.obj, undefined);
            }
            this.addSeparatingSpace();
        }
    }
}
exports.LanguageEnglish = LanguageEnglish;
//# sourceMappingURL=LanguageEnglish.js.map
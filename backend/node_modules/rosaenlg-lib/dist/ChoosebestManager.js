"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoosebestManager = void 0;
const synonym_optimizer_1 = require("synonym-optimizer");
class ChoosebestManager {
    setSpy(spy) {
        this.spy = spy;
    }
    getSpy() {
        return this.spy;
    }
    constructor(language, helper, saveRollbackManager, randomManager, defaultAmong) {
        this.spy = null;
        this.language = language;
        this.helper = helper;
        this.saveRollbackManager = saveRollbackManager;
        this.randomManager = randomManager;
        this.defaultAmong = defaultAmong;
        this.synOptimizer = new synonym_optimizer_1.SynOptimizer(language);
    }
    cleanupStringBeforeChooseBest(original) {
        /*
            do some cleanup:
            - ¤
            - html tags, including <protect>...</protect>
            (<span class="rosaenlg-debug" id="...">...<\/span> is already done)
          */
        let res = original;
        const regexHtml = /<(\/?)([a-zA-Z1-9_-]+).*?>/g; // same as in html.ts from rosaenlg-filter - update accordingly
        res = res.replace(regexHtml, ' ');
        res = res.replace(/[¤\s]+/g, ' ');
        return res;
    }
    runChoosebest(which, params) {
        if (this.saveRollbackManager.isEvaluatingChoosebest) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `choosebest cannot be imbricated`;
            throw err;
        }
        const debugOn = params && params.debug ? true : false;
        if (debugOn) {
            params.debugRes = {
                maxTest: null,
                perfectScoreAfter: null,
                bestScore: null,
                bestText: null,
                bestDebug: null,
                worstScore: null,
                worstText: null,
                worstDebug: null,
            };
        }
        let maxTest;
        if (params && params.among) {
            maxTest = params.among;
        }
        else {
            maxTest = this.defaultAmong;
        }
        if (debugOn) {
            params.debugRes.maxTest = maxTest;
        }
        if (debugOn) {
            params.debugRes.stop_words_add = params === null || params === void 0 ? void 0 : params.stop_words_add;
            params.debugRes.stop_words_remove = params === null || params === void 0 ? void 0 : params.stop_words_remove;
            params.debugRes.stop_words_override = params === null || params === void 0 ? void 0 : params.stop_words_override;
            params.debugRes.identicals = params === null || params === void 0 ? void 0 : params.identicals;
        }
        const newContentStart = this.getSpy().getPugHtml().length;
        // SIMULATE
        const scores = [];
        const alternatives = [];
        const debugInfos = [];
        for (let i = 0; i < maxTest; i++) {
            // SAVE
            this.saveRollbackManager.saveSituation('choosebest');
            this.randomManager.incrRnd(i);
            which(params);
            const generatedOriginal = this.helper.getHtmlWithoutRenderDebug(this.getSpy().getPugHtml().substring(newContentStart));
            const generated = this.cleanupStringBeforeChooseBest(generatedOriginal);
            // ROLLBACK
            this.saveRollbackManager.rollback();
            if (debugOn) {
                alternatives.push(generated);
            }
            const debugInfo = {
                filteredAlt: null,
                identicals: null,
                identicalsMap: null,
                wordsWithPos: null,
                score: null,
            };
            const score = this.synOptimizer.scoreAlternative(generated, params === null || params === void 0 ? void 0 : params.stop_words_add, params === null || params === void 0 ? void 0 : params.stop_words_remove, params === null || params === void 0 ? void 0 : params.stop_words_override, params === null || params === void 0 ? void 0 : params.identicals, debugOn ? debugInfo : null);
            scores.push(score);
            if (debugOn) {
                debugInfos.push(debugInfo);
            }
            // we can stop before if we ever get a perfect score
            if (score === 0) {
                if (debugOn) {
                    params.debugRes.perfectScoreAfter = i;
                }
                break;
            }
        }
        // CHOOSE BEST
        const best = scores.indexOf(Math.min(...scores));
        if (debugOn) {
            params.debugRes.bestScore = scores[best];
            params.debugRes.bestText = alternatives[best];
            params.debugRes.bestDebug = debugInfos[best];
            const worst = scores.indexOf(Math.max(...scores));
            params.debugRes.worstScore = scores[worst];
            params.debugRes.worstText = alternatives[worst];
            params.debugRes.worstDebug = debugInfos[worst];
        }
        // CHANGE RANDOM POSITION
        this.randomManager.incrRnd(best);
        // AND GENERATE IT
        which(params);
    }
}
exports.ChoosebestManager = ChoosebestManager;
//# sourceMappingURL=ChoosebestManager.js.map
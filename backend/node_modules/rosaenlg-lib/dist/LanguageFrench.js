"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageFrench = exports.frenchTenses = void 0;
const locale_1 = require("date-fns/locale");
const french_adjectives_wrapper_1 = require("french-adjectives-wrapper");
const french_determiners_1 = require("french-determiners");
const french_ordinals_1 = require("french-ordinals");
const french_verbs_1 = require("french-verbs");
const conjugations_json_1 = __importDefault(require("french-verbs-lefff/dist/conjugations.json"));
const french_words_1 = require("french-words");
const words_json_1 = __importDefault(require("french-words-gender-lefff/dist/words.json"));
const lefff_helper_1 = require("lefff-helper");
require("numeral/locales/fr");
const n2words_FR_js_1 = __importDefault(require("../../rosaenlg-n2words/dist/n2words_FR.js"));
const french_grammar_js_1 = require("../dist/french-grammar.js");
const LanguageImpl_1 = require("./LanguageImpl");
exports.frenchTenses = french_verbs_1.validTenses;
class LanguageFrench extends LanguageImpl_1.LanguageImpl {
    constructor(languageCommon) {
        super(languageCommon);
        this.iso2 = 'fr';
        this.langForNumeral = 'fr';
        this.langForDateFns = locale_1.fr;
        this.n2wordsLang = 'fr';
        this.n2wordsLib = n2words_FR_js_1.default;
        this.floatingPointWord = 'virgule';
        this.table0to9 = ['zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit', 'neuf'];
        this.hasGender = true;
        this.hasNeutral = false;
        this.defaultAdjPos = 'AFTER'; // In general, and unlike English, French adjectives are placed after the noun they describe
        this.defaultTense = 'PRESENT';
        this.defaultLastSeparatorForAdjectives = 'et';
        this.universalMapping = {
            UNIVERSAL_PRESENT: 'PRESENT',
            UNIVERSAL_PAST: 'IMPARFAIT',
            UNIVERSAL_FUTURE: 'FUTUR',
            UNIVERSAL_PERFECT: 'PASSE_COMPOSE',
            UNIVERSAL_PLUPERFECT: 'PLUS_QUE_PARFAIT',
        };
        this.spacesWhenSeparatingElements = true;
        try {
            this.dictHelper = new lefff_helper_1.LefffHelper();
        }
        catch (err) {
            // this means that we are in a browser
        }
    }
    getDet(detType, params) {
        const { genderOwned, numberOwned, numberOwner, adjectiveAfterDet, after, forceDes, personOwner } = params;
        return (0, french_determiners_1.getDet)({
            detType,
            genderOwned: genderOwned,
            numberOwned: numberOwned || 'S',
            numberOwner: numberOwner || 'S',
            personOwner: personOwner || 3,
            adjectiveAfterDet,
            contentAfterDet: after ? after.replace(/¤/g, ' ').trim() : undefined,
            forceDes,
        }); // we hope it is a string
    }
    getAgreeAdj(adjective, gender, number, subject, params) {
        return (0, french_adjectives_wrapper_1.agreeAdjective)(this.getDictManager().getAdjsData(), adjective, gender, number, subject, params && params.adjPos === 'BEFORE', this.getDictManager().getWordData());
    }
    getWordGender(word) {
        return (0, french_words_1.getGender)(this.getDictManager().getWordData(), words_json_1.default, word); //NOSONAR
    }
    getOrdinal(val, gender) {
        return (0, french_ordinals_1.getOrdinal)(val, gender);
    }
    getTextualNumber(val, gender) {
        if (val === 1) {
            return gender === 'F' ? 'une' : 'un';
        }
        else {
            return super.getTextualNumber(val, gender);
        }
    }
    getOrdinalNumber(val, gender) {
        if (val == 1) {
            if (gender == 'F') {
                return '1re'; // première
            }
            else {
                return '1er';
            }
        }
        else {
            // default implementation works fine for the rest
            return super.getOrdinalNumber(val, gender);
        }
    }
    getSubstantive(subst, number) {
        if (number === 'S') {
            return subst;
        }
        else {
            return (0, french_words_1.getPlural)(this.getDictManager().getWordData(), subst);
        }
    }
    parseSimplifiedString(val) {
        return (0, french_grammar_js_1.parse)(val, { dictHelper: this.dictHelper });
    }
    thirdPossessionTriggerRef(owner, owned, params) {
        this.valueManager.value(owned, Object.assign({}, params, { det: 'DEFINITE' }));
        this.getSpy().appendPugHtml(` de `);
        this.valueManager.value(owner, Object.assign({}, params));
    }
    thirdPossessionRefTriggered(owner, owned, params) {
        const det = this.getDet('POSSESSIVE', {
            genderOwned: this.genderNumberManager.getRefGender(owned, null),
            genderOwner: undefined,
            numberOwner: this.genderNumberManager.getRefNumber(owner, params),
            numberOwned: this.genderNumberManager.getRefNumber(owned, params),
            personOwner: (params && params.personOwner) || null,
            case: null,
            dist: null,
            after: undefined,
            useTheWhenPlural: undefined,
        });
        this.helper.insertSeparatingSpaceIfRequired();
        this.getSpy().appendPugHtml(det);
        this.helper.insertSeparatingSpaceIfRequired();
        this.valueManager.value(owned, Object.assign({}, params, { det: '' }));
    }
    recipientPossession(owned) {
        const nextRef = this.refsManager.getNextRep(owned, { _OWNER: true });
        // vos / votre + value of the object
        this.getSpy().appendPugHtml(this.helper.getSorP(['votre', 'vos'], nextRef) + ' ');
        this.valueManager.value(owned, { _OWNER: true });
    }
    getConjugation(subject, verb, originalTense, person, conjParams, embeddedVerbs) {
        const solvedTense = this.solveTense(originalTense);
        let pronominal = false;
        if (conjParams && conjParams.pronominal) {
            pronominal = true;
        }
        let aux = undefined;
        if (conjParams && conjParams.aux) {
            aux = conjParams.aux;
        }
        let voice = 'Act';
        if (conjParams && conjParams.voice) {
            voice = conjParams.voice;
        }
        let agreeGender = undefined;
        let agreeNumber = undefined;
        if (conjParams && conjParams.agree) {
            agreeGender = this.genderNumberManager.getRefGender(conjParams.agree, null);
            agreeNumber = this.genderNumberManager.getRefNumber(conjParams.agree, null);
        }
        else if ((0, french_verbs_1.isComposedTense)(solvedTense) || voice === 'Pass') {
            // no explicit "agree" param, but aux is ETRE, either clearly stated or is default,
            // then agreement of the participle must be automatic
            if (aux === 'ETRE' || (0, french_verbs_1.alwaysAuxEtre)(verb) || voice === 'Pass') {
                agreeGender = this.genderNumberManager.getRefGender(subject, null);
                agreeNumber = this.genderNumberManager.getRefNumber(subject, null);
            }
        }
        return (0, french_verbs_1.getConjugation)(embeddedVerbs || conjugations_json_1.default, // give the verbs that we embedded in the compiled template, if there are some; if nothing we use the lefff
        verb, solvedTense, this.mapPersonToNumber0to5(person), {
            aux: aux,
            agreeGender: agreeGender,
            agreeNumber: agreeNumber,
        }, pronominal, conjParams.negativeAdverb, conjParams.modifierAdverb, voice);
    }
    isPlural(val) {
        /*
          En français, seules les quantités égales ou supérieures à 2 prennent la marque du pluriel.
          Singulier -2 < N < 2
          Pluriel |N| ≥ 2 (N ≤ -2 ou N ≥ 2)
        */
        if (val >= 2 || val <= -2) {
            return true;
        }
        else {
            return false;
        }
    }
    getPersonalPronounSubject(person) {
        /* istanbul ignore next */
        if (person === '3S' || person === '3P') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `personal pronoun subject unknown: il / elle, ils / elles, etc.`;
            throw err;
        }
        return {
            '1S': 'je',
            '2S': 'tu',
            '1P': 'nous',
            '2P': 'vous',
        }[person];
    }
    getDirectObjPronoun(gender, number, person) {
        if (!person || person === '3S' || person === '3P') {
            if (number === 'P') {
                return 'les';
            }
            else {
                if (gender === 'M') {
                    return 'le';
                }
                else {
                    return 'la';
                }
            }
        }
        return {
            '1S': 'me',
            '2S': 'te',
            '1P': 'nous',
            '2P': 'vous',
        }[person];
    }
    getIndirectObjPronoun(gender, number, person) {
        if (!person || person === '3S' || person === '3P') {
            if (number === 'P') {
                return 'leur';
            }
            else {
                return 'lui';
            }
        }
        return {
            '1S': 'me',
            '2S': 'te',
            '1P': 'nous',
            '2P': 'vous',
        }[person];
    }
    sentence(sentenceParams) {
        var _a, _b, _c;
        const subject = sentenceParams.subjectGroup.subject;
        const verbalGroup = sentenceParams.verbalGroup;
        const subjectGroup = sentenceParams.subjectGroup;
        const hasVerb = verbalGroup && verbalGroup.verb;
        const objGroups = sentenceParams.objGroups != null ? sentenceParams.objGroups : [];
        // subject
        if (subjectGroup.noSubject !== true) {
            if (subjectGroup.person === '1S' ||
                subjectGroup.person === '2S' ||
                subjectGroup.person === '1P' ||
                subjectGroup.person === '2P') {
                // use pronoun
                this.valueManager.value(this.getPersonalPronounSubject(subjectGroup.person), undefined);
            }
            else {
                this.valueManager.value(subjectGroup.subject, subjectGroup.params);
            }
            this.addSeparatingSpace();
        }
        // 'ne' always comes after the subject, whatever pronouns we have
        if (sentenceParams.negative) {
            this.valueManager.value('ne', undefined);
            this.addSeparatingSpace();
        }
        // for pronouns, order is static: COD then COI
        const triggeredList = objGroups
            .filter((objGroup) => { var _a; return ((_a = objGroup.params) === null || _a === void 0 ? void 0 : _a.REPRESENTANT) !== 'ref'; })
            .filter((objGroup) => {
            var _a;
            return ((_a = objGroup.params) === null || _a === void 0 ? void 0 : _a.REPRESENTANT) === 'refexpr' ||
                (this.refsManager && this.refsManager.hasTriggeredRef(objGroup.obj));
        })
            .sort((objGroup1, objGroup2) => {
            // istanbul ignore next
            if (objGroup1.type === objGroup2.type) {
                return 0;
            }
            if (objGroup1.type === 'DIRECT' && objGroup2.type === 'INDIRECT') {
                return -1;
            }
            return 1;
        });
        let triggeredDirectObj = null;
        for (const triggered of triggeredList) {
            if (triggered.pronounForm) {
                this.valueManager.value(triggered.pronounForm, undefined);
            }
            else {
                const gender = this.genderNumberManager.getRefGender(triggered.obj, null);
                const number = this.genderNumberManager.getRefNumber(triggered.obj, null);
                let pronoun;
                if (triggered.type === 'DIRECT') {
                    triggeredDirectObj = triggered.obj; // to agree the verb
                    pronoun = this.getDirectObjPronoun(gender, number, (_a = triggered.params) === null || _a === void 0 ? void 0 : _a.person);
                }
                else {
                    // INDIRECT
                    pronoun = this.getIndirectObjPronoun(gender, number, (_b = triggered.params) === null || _b === void 0 ? void 0 : _b.person);
                }
                this.valueManager.value(pronoun, undefined);
            }
            this.addSeparatingSpace();
        }
        // verb
        if (hasVerb) {
            const modifiedVerbalGroup = Object.assign({}, verbalGroup);
            // if there is a diretObj, voice has to be active
            if ((0, french_verbs_1.isComposedTense)(verbalGroup.tense) &&
                (0, french_verbs_1.getAux)(verbalGroup.verb, verbalGroup.aux, undefined) &&
                triggeredDirectObj !== null) {
                modifiedVerbalGroup.agree = triggeredDirectObj;
            }
            if (sentenceParams.negative) {
                // The use of ?? (and not ||) in the folowwing asserton allow to pass an empty string as negativeAdverb
                modifiedVerbalGroup.negativeAdverb = (_c = sentenceParams.negativeAdverb) !== null && _c !== void 0 ? _c : 'pas';
            }
            modifiedVerbalGroup.modifierAdverb = sentenceParams.modifierAdverb;
            this.valueManager.value(this.verbsManager.getAgreeVerb(subject, subjectGroup.person, modifiedVerbalGroup, null), undefined);
            this.addSeparatingSpace();
        }
        // the order must be respected
        const notTriggeredList = objGroups.filter((objGroup) => triggeredList.indexOf(objGroup) === -1);
        for (const objGroup of notTriggeredList) {
            if (objGroup.type === 'DIRECT') {
                this.valueManager.value(objGroup.obj, objGroup.params);
            }
            else {
                // INDIRECT
                if (objGroup.preposition) {
                    this.valueManager.value(objGroup.preposition, undefined);
                }
                this.valueManager.value(objGroup.obj, objGroup.params);
            }
            this.addSeparatingSpace();
        }
    }
}
exports.LanguageFrench = LanguageFrench;
//# sourceMappingURL=LanguageFrench.js.map
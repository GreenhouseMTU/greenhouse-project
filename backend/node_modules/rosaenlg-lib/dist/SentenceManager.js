"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SentenceManager = void 0;
class SentenceManager {
    constructor(languageImpl, verbsManager, valueManager, adjectiveManager, synManager, helper) {
        this.spy = undefined;
        this.languageImpl = languageImpl;
        this.verbsManager = verbsManager;
        this.valueManager = valueManager;
        this.adjectiveManager = adjectiveManager;
        this.synManager = synManager;
        this.helper = helper;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getSpy() {
        return this.spy;
    }
    verb(subject, verbInfo, params) {
        this.subjectVerb(subject, verbInfo, Object.assign(Object.assign({}, params), { noSubject: true }));
    }
    subjectVerb(subject, verbInfo, params) {
        // might have been done before if we go through subjectVerbAdj
        // but not if we use the mixin directly
        const chosenSubject = this.synManager.synFctHelper(subject);
        if (params && params.invertSubjectVerb) {
            if (!this.languageImpl.supportsInvertSubjectVerb) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `invertSubjectVerb is only valid for de_DE`;
                throw err;
            }
            if (typeof params.invertSubjectVerb !== 'boolean') {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `invertSubjectVerb must be a boolean`;
                throw err;
            }
        }
        if (params && params.noSubject) {
            this.getSpy().appendPugHtml(this.verbsManager.getAgreeVerb(chosenSubject, null, verbInfo, params));
        }
        else {
            if (params && params.invertSubjectVerb) {
                this.getSpy().appendPugHtml(this.helper.getSeparatingSpace() +
                    this.verbsManager.getAgreeVerb(chosenSubject, null, verbInfo, params) +
                    this.helper.getSeparatingSpace());
                this.valueManager.value(chosenSubject, params);
            }
            else {
                // warning: value has side effects on chosenSubject, typically number
                // thus we cannot agree the verb before running value
                this.valueManager.value(chosenSubject, params);
                this.getSpy().appendPugHtml(this.helper.getSeparatingSpace() +
                    this.verbsManager.getAgreeVerb(chosenSubject, null, verbInfo, params) +
                    this.helper.getSeparatingSpace());
            }
        }
    }
    subjectVerbAdj(subject, verbInfo, adjective, params) {
        const chosenSubject = this.synManager.synFctHelper(subject);
        this.subjectVerb(chosenSubject, verbInfo, params);
        // this already adds spaces
        this.adjectiveManager.agreeAdj(adjective, chosenSubject, params);
    }
    sentence(sentenceParams) {
        // some checks are multilingual
        if (!sentenceParams.subjectGroup) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `sentence requires a subject group`;
            throw err;
        }
        if (!sentenceParams.subjectGroup.subject && !sentenceParams.subjectGroup.person) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `within a subject group, subject object or person is required`;
            throw err;
        }
        if (sentenceParams.verbalGroup && !sentenceParams.verbalGroup.verb) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verb is required in a verbal group of a sentence`;
            throw err;
        }
        if (sentenceParams.objGroups) {
            for (const objGroup of sentenceParams.objGroups) {
                if (objGroup.type !== 'DIRECT' && objGroup.type !== 'INDIRECT') {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `group type is required: DIRECT or INDIRECT`;
                    throw err;
                }
                if (!objGroup.obj) {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = `obj is required in a direct or indirect object group of a sentence`;
                    throw err;
                }
            }
        }
        // realization is delegated for each language
        this.languageImpl.sentence(sentenceParams);
    }
}
exports.SentenceManager = SentenceManager;
//# sourceMappingURL=SentenceManager.js.map
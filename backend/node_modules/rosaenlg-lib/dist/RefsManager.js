"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.RefsManager = void 0;
class RefsManager {
    constructor(saveRollbackManager, genderNumberManager, randomManager) {
        this.valueManager = undefined;
        this.spy = undefined;
        this.saveRollbackManager = saveRollbackManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.triggeredRefs = new Map();
        this.nextRefs = new Map();
    }
    setValueManager(valueManager) {
        this.valueManager = valueManager;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getSpy() {
        return this.spy;
    }
    getNextRefs() {
        return this.nextRefs;
    }
    setNextRefs(nextRefs) {
        this.nextRefs = nextRefs;
    }
    getTriggeredRefs() {
        return this.triggeredRefs;
    }
    setTriggeredRefs(triggeredRefs) {
        this.triggeredRefs = triggeredRefs;
    }
    getNextRef(obj) {
        return this.nextRefs.get(this.getKey(obj));
    }
    setNextRef(obj, nextRef) {
        this.nextRefs.set(this.getKey(obj), nextRef);
    }
    getNextRep(obj, params) {
        if (!obj) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `getNextRep called on null object`;
            throw err;
        }
        // there's already one planned
        if (this.getNextRef(obj) !== undefined) {
            return this.getNextRef(obj);
        }
        // simulate
        const rndNextPosBefore = this.randomManager.getRndNextPos();
        this.saveRollbackManager.saveSituation('nextRep');
        const hadRefBefore = this.hasTriggeredRef(obj);
        const lengthBefore = this.getSpy().getPugHtml().length;
        // cross dependency prevents from calling the function directly
        this.valueManager.value(obj, params);
        // record the result before rollback
        const nextRef = {
            valueForDebug: this.getSpy().getPugHtml().substring(lengthBefore),
            // we don't care about what will be triggered, but only if it has been triggered before
            REPRESENTANT: hadRefBefore ? 'refexpr' : 'ref',
            gender: this.genderNumberManager.getRefGender(obj, null),
            number: this.genderNumberManager.getRefNumber(obj, null),
            rndNextPos: rndNextPosBefore,
        };
        // rollback
        this.saveRollbackManager.rollback();
        // register the result
        this.genderNumberManager.setRefGenderNumber(nextRef, nextRef.gender, nextRef.number);
        // save the nextRef for use when it will actually be triggered
        this.setNextRef(obj, nextRef);
        return nextRef;
    }
    getKey(obj) {
        return obj;
    }
    resetRep(obj) {
        this.triggeredRefs.delete(this.getKey(obj));
        // if we had asked for a next ref
        this.nextRefs.delete(this.getKey(obj));
    }
    hasTriggeredRef(obj) {
        return this.triggeredRefs.get(this.getKey(obj)) ? true : false;
    }
    setTriggeredRef(obj) {
        this.triggeredRefs.set(this.getKey(obj), true);
    }
    deleteNextRef(obj) {
        this.nextRefs.delete(this.getKey(obj));
    }
}
exports.RefsManager = RefsManager;
//# sourceMappingURL=RefsManager.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getConjugation = exports.getTenseAuxPassive = exports.getTenseAux = exports.getAuxPassive = exports.getAux = exports.isTransitive = exports.isNoPersonTense = exports.isComposedTense = exports.validTenses = exports.alwaysAuxEtre = exports.getVerbInfo = void 0;
/*

8 temps de l'indicatif :
  Présent
  Passé composé
  Imparfait
  Plus-que-parfait
  Passé simple
  Passé antérieur
  Futur simple
  Futur antérieur

4 temps du subjonctif :
  Présent
  Passé
  Imparfait
  Plus-que-parfait

3 temps du conditionnel :
  Présent
  Passé 1ère forme
  Passé 2ème forme

2 temps de l'impératif :
  Présent
  Passé

2 temps du participe :
  Présent
  Passé

2 temps de l'infinitif :
  Présent
  Passé

2 temps du gérondif :
  Présent
  Passé
*/
const french_contractions_1 = require("french-contractions");
const conjAvoir = {
    P: ['ai', 'as', 'a', 'avons', 'avez', 'ont'],
    S: ['aie', 'aies', 'ait', 'ayons', 'ayez', 'aient'],
    Y: ['NA', 'aie', 'NA', 'ayons', 'ayez', 'NA'],
    F: ['aurai', 'auras', 'aura', 'aurons', 'aurez', 'auront'],
    C: ['aurais', 'aurais', 'aurait', 'aurions', 'auriez', 'auraient'],
    I: ['avais', 'avais', 'avait', 'avions', 'aviez', 'avaient'],
    W: ['avoir'],
    G: ['ayant'],
    K: ['eu', 'eus', 'eue', 'eues'],
    J: ['eus', 'eus', 'eut', 'eûmes', 'eûtes', 'eurent'],
    T: ['eusse', 'eusses', 'eût', 'eussions', 'eussiez', 'eussent'],
};
const conjEtre = {
    P: ['suis', 'es', 'est', 'sommes', 'êtes', 'sont'],
    J: ['fus', 'fus', 'fut', 'fûmes', 'fûtes', 'furent'],
    T: ['fusse', 'fusses', 'fût', 'fussions', 'fussiez', 'fussent'],
    F: ['serai', 'seras', 'sera', 'serons', 'serez', 'seront'],
    C: ['serais', 'serais', 'serait', 'serions', 'seriez', 'seraient'],
    S: ['sois', 'sois', 'soit', 'soyons', 'soyez', 'soient'],
    Y: ['NA', 'sois', 'NA', 'soyons', 'soyez', 'NA'],
    I: ['étais', 'étais', 'était', 'étions', 'étiez', 'étaient'],
    G: ['étant'],
    K: ['été', 'été', 'été', 'été'],
    W: ['être'],
};
function getVerbInfo(verbsInfo, verb) {
    if (verb === 'avoir')
        return conjAvoir;
    if (verb === 'être')
        return conjEtre;
    if (!verbsInfo) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'verbs list must not be null';
        throw err;
    }
    const verbInfo = verbsInfo[verb];
    if (!verbInfo) {
        const err = new Error();
        err.name = 'NotFoundInDict';
        err.message = `${verb} not in dict`;
        throw err;
    }
    return verbInfo;
}
exports.getVerbInfo = getVerbInfo;
// is required at runtime (not only comp)
const listEtre = [
    'aller',
    'apparaître',
    'arriver',
    'débeller',
    'décéder',
    'devenir',
    'échoir',
    'entrer',
    'intervenir',
    'mourir',
    'naitre',
    'naître',
    'partir',
    'parvenir',
    'provenir',
    'redevenir',
    'repartir',
    'rester',
    'resurvenir',
    'retomber',
    'revenir',
    'survenir',
    'tomber',
    'venir',
];
function alwaysAuxEtre(verb) {
    return listEtre.indexOf(verb) > -1;
}
exports.alwaysAuxEtre = alwaysAuxEtre;
const transitive_json_1 = __importDefault(require("french-verbs-transitive/dist/transitive.json"));
// The following list is the exhaustive list of French tenses
exports.validTenses = [
    'PRESENT',
    'FUTUR',
    'IMPARFAIT',
    'PASSE_SIMPLE',
    'PASSE_COMPOSE',
    'PLUS_QUE_PARFAIT',
    'PASSE_ANTERIEUR',
    'FUTUR_ANTERIEUR',
    'CONDITIONNEL_PRESENT',
    'CONDITIONNEL_PASSE_1',
    'CONDITIONNEL_PASSE_2',
    'IMPERATIF_PRESENT',
    'IMPERATIF_PASSE',
    'SUBJONCTIF_PRESENT',
    'SUBJONCTIF_IMPARFAIT',
    'SUBJONCTIF_PASSE',
    'SUBJONCTIF_PLUS_QUE_PARFAIT',
    'INFINITIF',
    'INFINITIF_PASSE',
    'PARTICIPE_PRESENT',
    'PARTICIPE_PASSE',
    'PARTICIPE_PASSE_COMPOSE',
];
const composedTenses = [
    'PASSE_COMPOSE',
    'PLUS_QUE_PARFAIT',
    'PASSE_ANTERIEUR',
    'FUTUR_ANTERIEUR',
    'CONDITIONNEL_PASSE_1',
    'CONDITIONNEL_PASSE_2',
    'IMPERATIF_PASSE',
    'SUBJONCTIF_PASSE',
    'SUBJONCTIF_PLUS_QUE_PARFAIT',
    'INFINITIF_PASSE',
    'PARTICIPE_PASSE',
    'PARTICIPE_PASSE_COMPOSE',
];
const noPersonTenses = [
    'INFINITIF',
    'INFINITIF_PASSE',
    'PARTICIPE_PRESENT',
    'PARTICIPE_PASSE',
    'PARTICIPE_PASSE_COMPOSE',
];
const isComposedTense = (tense) => {
    return composedTenses.indexOf(tense) > -1;
};
exports.isComposedTense = isComposedTense;
const isNoPersonTense = (tense) => {
    return noPersonTenses.indexOf(tense) > -1;
};
exports.isNoPersonTense = isNoPersonTense;
function isTransitive(verb) {
    return transitive_json_1.default.indexOf(verb) > -1;
}
exports.isTransitive = isTransitive;
const tenseMapping = {
    PRESENT: 'P',
    FUTUR: 'F',
    IMPARFAIT: 'I',
    PASSE_SIMPLE: 'J',
    CONDITIONNEL_PRESENT: 'C',
    IMPERATIF_PRESENT: 'Y',
    SUBJONCTIF_PRESENT: 'S',
    SUBJONCTIF_IMPARFAIT: 'T',
    PARTICIPE_PASSE: 'K',
    PARTICIPE_PRESENT: 'G',
    INFINITIF: 'W', // infinitif présent
};
function getAux(verb, aux, pronominal) {
    if (aux) {
        if (aux != 'AVOIR' && aux != 'ETRE') {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `aux must be AVOIR or ETRE`;
            throw err;
        }
        else {
            return aux;
        }
    }
    else {
        if (pronominal) {
            return 'ETRE';
        }
        else if (alwaysAuxEtre(verb)) {
            return 'ETRE';
        }
        else if (isTransitive(verb)) {
            return 'AVOIR'; // rather AVOIR if not specified
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `aux property must be set with this tense for ${verb}`;
            throw err;
        }
    }
}
exports.getAux = getAux;
function getAuxPassive(tense) {
    if ((0, exports.isComposedTense)(tense)) {
        return 'AVOIR';
    }
    return 'ETRE';
}
exports.getAuxPassive = getAuxPassive;
function getTenseAux(tense) {
    switch (tense) {
        case 'PASSE_COMPOSE':
            return 'P';
        case 'PLUS_QUE_PARFAIT':
            return 'I';
        case 'PASSE_ANTERIEUR':
            return 'J';
        case 'FUTUR_ANTERIEUR':
            return 'F';
        case 'CONDITIONNEL_PASSE_1':
            return 'C';
        case 'CONDITIONNEL_PASSE_2':
            return 'T';
        case 'IMPERATIF_PASSE':
            return 'Y';
        case 'SUBJONCTIF_PASSE':
            return 'S';
        case 'SUBJONCTIF_PLUS_QUE_PARFAIT':
            return 'T';
        case 'INFINITIF_PASSE':
            return 'W';
        case 'PARTICIPE_PASSE_COMPOSE':
            return 'G';
        case 'PARTICIPE_PASSE': //not really useful
            return 'P';
    }
}
exports.getTenseAux = getTenseAux;
function getTenseAuxPassive(tense) {
    if ((0, exports.isComposedTense)(tense)) {
        return getTenseAux(tense);
    }
    return tenseMapping[tense];
}
exports.getTenseAuxPassive = getTenseAuxPassive;
function getConjugatedComposedTenseOrPassive(verbInfo, verb, tense, person, composedTenseOptions, pronominal, negativeAdverb, modifierAdverb, voice) {
    if (!composedTenseOptions) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `ComposedTenseOptions is mandatory when tense is composed or voice passive`;
        throw err;
    }
    const agreeGender = composedTenseOptions.agreeGender || 'M';
    const agreeNumber = composedTenseOptions.agreeNumber || 'S';
    const aux = voice === 'Pass' ? getAuxPassive(tense) : getAux(verb, composedTenseOptions.aux, pronominal);
    const tempsAux = voice === 'Pass' ? getTenseAuxPassive(tense) : getTenseAux(tense);
    // get conjugated aux
    const auxInfo = getVerbInfo(null, aux === 'AVOIR' ? 'avoir' : 'être');
    const conjugatedAux = (0, exports.isNoPersonTense)(tense)
        ? auxInfo[tempsAux][0]
        : auxInfo[tempsAux][person];
    const participePasseList = verbInfo['K'];
    if (!participePasseList) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `no participe passé for ${verb}`;
        throw err;
    }
    const mappingGenderNumber = { MS: 0, MP: 1, FS: 2, FP: 3 };
    const indexGenderNumber = mappingGenderNumber[agreeGender + agreeNumber];
    const participePasse = voice === 'Pass' && (0, exports.isComposedTense)(tense)
        ? 'été ' + participePasseList[indexGenderNumber]
        : participePasseList[indexGenderNumber];
    /* istanbul ignore if */
    if (!participePasse) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `no participe passé form for ${verb}`;
        throw err;
    }
    const conjugatedAuxWithPronominal = pronominal
        ? processPronominal(verb, person, conjugatedAux) + ' '
        : conjugatedAux + ' ';
    const insertModifier = modifierAdverb ? modifierAdverb + ' ' : '';
    const insertNegative = negativeAdverb ? negativeAdverb + ' ' : '';
    const resWithNegative = (tense === 'PARTICIPE_PASSE' ? '' : conjugatedAuxWithPronominal) + insertNegative + insertModifier + participePasse;
    return resWithNegative;
}
function getConjugatedNoComposedAndActive(verbInfo, verb, tense, person, negativeAdverb, modifierAdverb, pronominal) {
    const indexTemps = tenseMapping[tense];
    const tenseInLib = verbInfo[indexTemps];
    if (!tenseInLib) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `${tense} tense not available in French for ${verb}`;
        throw err;
    }
    const formInLib = (0, exports.isNoPersonTense)(tense) ? tenseInLib[0] : tenseInLib[person];
    if (!formInLib || formInLib === 'NA') {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `person ${person} not available in French for ${verb} in ${tense}`;
        throw err;
    }
    const conjugated = pronominal ? processPronominal(verb, person, formInLib) : formInLib;
    if (tense === 'INFINITIF') {
        const insertModifier = modifierAdverb ? modifierAdverb + ' ' : '';
        const insertNegative = negativeAdverb ? negativeAdverb + ' ' : '';
        return insertNegative + insertModifier + conjugated;
    }
    const insertModifier = modifierAdverb ? ' ' + modifierAdverb : '';
    const insertNegative = negativeAdverb ? ' ' + negativeAdverb : '';
    return conjugated + insertNegative + insertModifier;
}
function processPronominal(verb, person, conjugated) {
    const pronominalMapping = ['me', 'te', 'se', 'nous', 'vous', 'se'];
    let contract = false;
    if ([0, 1, 2, 5].indexOf(person) > -1) {
        // potential contraction
        // for the h muet test: take infinitive, not conjugated form (list does not contain flex forms)
        if (((0, french_contractions_1.beginsWithVowel)(conjugated) && (0, french_contractions_1.isContractedVowelWord)(conjugated)) || (0, french_contractions_1.isHMuet)(verb)) {
            contract = true;
        }
    }
    if (contract) {
        return `${pronominalMapping[person].substring(0, 1)}'${conjugated}`;
    }
    else {
        return `${pronominalMapping[person]} ${conjugated}`;
    }
}
function getConjugation(verbsList, verb, tense, person, composedTenseOptions, pronominal, negativeAdverb, modifierAdverb, voice) {
    if (!verb) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'verb must not be null';
        throw err;
    }
    if (person == null && (!(0, exports.isNoPersonTense)(tense) || pronominal)) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = 'person must not be null';
        throw err;
    }
    if (!tense || exports.validTenses.indexOf(tense) === -1) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `tense must be ${exports.validTenses.join()}`;
        throw err;
    }
    // s'écrier, se rendre...
    if (verb.startsWith('se ')) {
        pronominal = true;
        verb = verb.replace(/^se\s+/, '');
    }
    else if (verb.startsWith("s'")) {
        pronominal = true;
        verb = verb.replace(/^s'\s*/, '');
    }
    const verbInfo = getVerbInfo(verbsList, verb);
    let conjugated;
    if ((0, exports.isComposedTense)(tense) || voice === 'Pass') {
        conjugated = getConjugatedComposedTenseOrPassive(verbInfo, verb, tense, person, composedTenseOptions, pronominal, negativeAdverb, modifierAdverb, voice);
    }
    else {
        conjugated = getConjugatedNoComposedAndActive(verbInfo, verb, tense, person, negativeAdverb, modifierAdverb, pronominal);
    }
    return conjugated;
}
exports.getConjugation = getConjugation;
//# sourceMappingURL=index.js.map